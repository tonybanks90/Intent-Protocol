#[test_only]
module intent_swap::scenario_tests {
    use std::signer;
    use std::vector;
    use std::string;

    use aptos_framework::account;
    use aptos_framework::coin::{Self, MintCapability, BurnCapability, FreezeCapability};
    use aptos_framework::timestamp;
    use aptos_std::type_info;


    use intent_swap::swap;
    use intent_swap::escrow;

    // ==================== Test Currencies ====================

    struct USDC {}
    struct MOVE {}

    struct TestCaps<phantom CoinType> has key {
        mint_cap: MintCapability<CoinType>,
        burn_cap: BurnCapability<CoinType>,
        freeze_cap: FreezeCapability<CoinType>,
    }

    // ==================== Setup Helpers ====================

    fun setup_coin<CoinType>(admin: &signer) {
        let name = string::utf8(b"Test Coin");
        let symbol = string::utf8(b"TEST");
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
            admin,
            name,
            symbol,
            6, // decimals
            false, // monitor_supply
        );
        move_to(admin, TestCaps { mint_cap, burn_cap, freeze_cap });
    }

    fun mint_to<CoinType>(admin: &signer, to: address, amount: u64) acquires TestCaps {
        let admin_addr = signer::address_of(admin);
        let caps = borrow_global<TestCaps<CoinType>>(admin_addr);
        let coins = coin::mint(amount, &caps.mint_cap);
        if (!coin::is_account_registered<CoinType>(to)) {
            coin::register<CoinType>(&account::create_account_for_test(to));
        };
        coin::deposit(to, coins);
    }

    fun get_mock_signature(): vector<u8> {
        let sig = vector::empty();
        let i = 0;
        while (i < 64) {
            vector::push_back(&mut sig, 0xAA);
            i = i + 1;
        };
        sig
    }

    // ==================== Scenario Test ====================

    // ==================== Scenario Test ====================

    // Hardcoded test vectors generated by scripts/generate_test_signature.js
    // Maker Address: 0x373637fed96c21f5cd50b8a795d52fc0055da6fb14c86027181e5a2132d15643
    // Private Key (for ref): 0x3fd13105c31514073374970156ee13c81907d63d98cd4150b7fba18ec54dd51f
    
    const MAKER_ADDR_BYTES: vector<u8> = x"373637fed96c21f5cd50b8a795d52fc0055da6fb14c86027181e5a2132d15643";
    const MAKER_PUBKEY: vector<u8> = x"2987ce958237a2e91126e406e7c19e3477738d6f778e6959d43e060618a9e6cd";
    // Digest: 0xa76d1a448d8d926241ecbe0a11715047d3c48e514ead51ebe54b350159dba5e6
    const SIGNATURE: vector<u8> = x"9233246c6f47166ba01afda8084c906cf817ebed83eacd5206a8e9672cc73e70268c9ee0b412399e0114930ab2e608ca8c94ec5b66320b8c01207bf8b3b2df05";

    #[test(admin = @intent_swap, resolver = @0x200)]
    fun test_full_swap_scenario(
        admin: &signer,
        resolver: &signer
    ) acquires TestCaps {
        // ----------------------------------------------------------------
        // 1. Setup Environment
        // ----------------------------------------------------------------
        let framework = account::create_account_for_test(@0x1);
        timestamp::set_time_has_started_for_testing(&framework);
        let admin_addr = signer::address_of(admin);
        let resolver_addr = signer::address_of(resolver);

        // Create Maker account from hardcoded address
        // Note: aptos_framework::account::create_account_for_test creates an account with auth key = address
        // But our verification requires auth key to be sha3_256(pubkey | 0x00).
        // Since we can't easily fetch the private key inside Move to rotate_key, 
        // we must simulate the account being created with the CORRECT auth key.
        // `create_account_for_test` doesn't let us set auth key easily.
        // However, `account::create_account(addr)` fails if exists.
        
        // Strategy: 
        // 1. Create account with `account::create_account_for_test(maker_addr)`.
        // 2. This sets AuthKey = maker_addr.
        // 3. Our maker_addr IS the auth key (if using standard scheme)?
        // Aptos standard: Address = SHA3-256(PublicKey | 0x00).
        // So `maker_addr` IS the auth key.
        // `account::create_account_for_test` sets the `AuthenticationKey` resource to `bcs::to_bytes(addr)`.
        // Wait, `create_account_for_test` matches address.
        // Let's verify `verifier.move` logic:
        // `let on_chain_auth_key = account::get_authentication_key(maker);`
        // `let derived_auth_key = hash::sha3_256(expected_auth_key);`
        // `if (derived_auth_key != on_chain_auth_key) ...`
        
        // Valid Aptos Account: 
        // Address = AuthKey (usually).
        // If we use standard derivation, `maker_addr` generated by SDK is the AuthKey.
        // `create_account_for_test` creates an account at `maker_addr` and sets its AuthKey to `maker_addr` (as bytes).
        // So the check `derived_auth_key == on_chain_auth_key` should PASS if `maker_addr` was derived correctly in the script.
        
        // Convert vector<u8> to address
        let maker_addr = aptos_framework::from_bcs::to_address(MAKER_ADDR_BYTES);
        let maker = &account::create_account_for_test(maker_addr);

        // Initialize contracts
        swap::initialize(admin);
        escrow::initialize(admin);
        escrow::set_swap_contract(admin, admin_addr, admin_addr); // admin is where swap registry lives

        // Setup Tokens
        setup_coin<MOVE>(admin);
        setup_coin<USDC>(admin);

        // Mint initial balances
        mint_to<MOVE>(admin, maker_addr, 1000_000000); // 1000 MOVE
        mint_to<USDC>(admin, resolver_addr, 5000_000000); // 5000 USDC

        // ----------------------------------------------------------------
        // 2. Maker Deposits to Escrow
        // ----------------------------------------------------------------
        
        // Deposit 100 MOVE to escrow
        escrow::deposit<MOVE>(maker, 100_000000);

        // Verify state
        assert!(coin::balance<MOVE>(maker_addr) == 900_000000, 100);
        assert!(escrow::get_balance<MOVE>(maker_addr) == 100_000000, 101);

        // ----------------------------------------------------------------
        // 3. Define Intent
        // ----------------------------------------------------------------
        
        let start_time = 10000;
        let end_time = 11000;
        let sell_amount = 100_000000;
        let start_buy_amount = 200_000000;
        let end_buy_amount = 150_000000;
        
        let sell_token_bytes = *string::bytes(&type_info::type_name<MOVE>());
        let buy_token_bytes = *string::bytes(&type_info::type_name<USDC>());

        // ----------------------------------------------------------------
        // 4. Advance Time and Simulate Auction
        // ----------------------------------------------------------------

        // Move time to middle of auction (10500)
        timestamp::update_global_time_for_test_secs(10500);

        // Expected price at 50% progress should be 175 USDC
        let expected_price = 175_000000;

        // ----------------------------------------------------------------
        // 5. Resolver Fills Order
        // ----------------------------------------------------------------

        let nonce = 0; // First order for this user

        // Resolver must be registered for generic coins in the swap function's scope?
        // Yes, verify resolver has the SellCoin registered (to receive it)
        if (!coin::is_account_registered<MOVE>(resolver_addr)) {
             coin::register<MOVE>(resolver);
        };
        // Verify maker has BuyCoin registered (to receive it)
        if (!coin::is_account_registered<USDC>(maker_addr)) {
             coin::register<USDC>(maker);
        };



        // Call fill_order
        swap::fill_order<MOVE, USDC>(
            resolver,
            admin_addr, // Registry address
            maker_addr,
            nonce,
            sell_token_bytes,
            buy_token_bytes,
            sell_amount,
            start_buy_amount,
            end_buy_amount,
            start_time,
            end_time,
            expected_price, // Pay exactly the current price
            SIGNATURE,
            MAKER_PUBKEY
        );

        // ----------------------------------------------------------------
        // 6. Verify Final State
        // ----------------------------------------------------------------

        // Maker:
        // - Started with 1000 MOVE
        // - Deposited 100 -> 900 MOVE Wallet, 100 MOVE Escrow
        // - Swapped 100 MOVE Escrow -> 0 MOVE Escrow
        // - Received 175 USDC
        assert!(coin::balance<MOVE>(maker_addr) == 900_000000, 200);
        assert!(escrow::get_balance<MOVE>(maker_addr) == 0, 201);
        assert!(coin::balance<USDC>(maker_addr) == 175_000000, 202);

        // Resolver:
        // - Started with 5000 USDC
        // - Paid 175 USDC -> 4825 USDC
        // - Received 100 MOVE
        assert!(coin::balance<USDC>(resolver_addr) == 4825_000000, 300);
        assert!(coin::balance<MOVE>(resolver_addr) == 100_000000, 301);

        // Registry:
        // - Volume should be 100 MOVE
        assert!(swap::get_total_filled(admin_addr) == 1, 400);
        assert!(swap::get_total_volume(admin_addr) == (sell_amount as u128), 401);
        
        // Nonce should be incremented
        assert!(swap::get_nonce(admin_addr, maker_addr) == 1, 402);
    }
}
